Note: In Index.css we setup global body style since rendor starts from Index.js and we import it in Index.js
//To change font-family from imported fonts from google -> Public -> Index.html
//We will use component to manage state and container for everything else
//<main> Tag is used to showcase main content
//IF we have two adjacent jsx element (we can't have), We have to use array and give each item a key
//Another alternate is create HOC -> It will server purpose of wrapping something and passing function
//Question to ask, Why didn't we used div?
https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/t/lecture/8109010?start=0
//if we import react, can we use jsx anywhere?
//we can also add state using constructor(Props), super(props); this.state (this because we are inside a method)
//Burger project lecture 11 to know how to pass states to functional component

//Burger Ingrident safe guarding.
https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/questions/3956582

More on CSS Modules
https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/t/lecture/8111608

//Question.
//When we console.log(typeof array) -> Does it always logs it as an object

//To do
//Read flex properties (flex-flow, flex wrapper), display flex
..Read when do we use <Something> </something> and when do we use <something... />
.TO understand why do we make array of an object





//Lecture 5
//Css -> Npm run eject -> webpack -> Options
//Removed logo
//Removed most of the content from App.js
//Index.css change font
//removed App.css
//-------------------
//-------------------
//-------------------





//lecture 6
//We can seperate our project into two parts
//Toolbar to navigate and the main burger builder
//We create a sub folder for layout
//We created Component and container -> we will create container in components because we don't need to manage any state
//In components -> Sub folder -> Layout -> in layout , layout.js file
//We create assests folder
//In layout.js, we use *main and there we will put component we will wrap with this content -> hence we will use props.children
//*We use this component as a wrapper around the core content component we want to render to the screen
//Now in main.js,we want have two adjacent element but since we cannot have two adjacet JSX element together, we create HOC named Aux
//Aux is simple -> Takes props and return props
//We import Aux to our Layout and layout to app
//Run the app afterwards
//-------------------
//-------------------
//-------------------





//Lecture 7
//Starting the implementation of the burger builder
//---x-x----x--x---
//This should actually be a container because here we need to manage the state of burger
//We created a new folder in container known as burger Builder
//Burger Builder contains Burger and Burger Controls
//We wrap it with Aux like we wrapped layout
//We imported it to App.js
//We wrapped it inside layout.js, Since we wrapped it inside Layout.js, We could add styling in Layout.css which will effect it since we are passing props.children
//We created layout.csss and added maegin of 16px
//Overflow: Scroll -> We can scroll it
//-------------------
//-------------------
//-------------------





//Lecture 8
//Adding DYnamic ingredient components
//---x----x-----x---
//We would add burger needed component and ingredients
//We added the CSS provided to us by Max
//We created Burger-ingredient cascade Style sheet and Burger-ingrident.js
//Now there would be different ingridents which we tend to send from Burger.js from props
//In burger-Ingrident.js file, we create a functional component and import react since we are going to use jsx
//We created a ingrident variable and set it as value to null because we don't want any invalid Value to be passed (more like let ingrident;) -> We won't render anything
//In Switch statement we do props.type -> type is the property we expect to receive -> based on the type we receive will use the case
//-------------------
//-------------------
//-------------------





//Lecture 9
//Props Valiadtion
//--x--x----x--
//Added Props Validation
//-------------------
//-------------------
//-------------------





//Lecture 10
//Starting the burger Component
//---x----x---
//In burger.js, we created a functional component which receives some props
//we imported react and BurgerIngredients.js
//We added types under <BurgerIngredients which will passed as props.type to our BurgerIngredients.js
//we created burger.css and added some css and media query
//All the props are static and added manually they look like this   <BurgerIngredients type="bread-top"/> <BurgerIngredients type="meat"/> and wrapped everything with div and added our own styling
//Since we are using switch statement > as we pass props.type > it will forward this to switch and hence display it
//We imported this to container > burger Builder > burger Builder.js
//-------------------
//-------------------
//-------------------





Lecture 11
//Outputting burger ingredient Dynamically
//----x-----x----
//We will add state, state is an object (in max tutorial) -> max
//We pass this array to burger Ingredients through  <Burger ingredient={this.state.ingrident}/> and convert this object to array using Object.keys
//Then we will use 1st map to find the property of the associated objected for example salad:1 -> we will find the property, which is one here -> this is done through
return [...Array(props.ingredient[igKey])] -> This will return a single empty array in case of 1, two empty array in case of 2 and so on..
will map this return and pass in the value of the string which will get as loop progress, this value is pushed in as form of JSX to form an Array
//SInce we are using one variable here, transformedIngrident, we use JSx to insert our value by doing something like this in return {transformedIngrident}

-----Max code alternate classical simplified version----

////Max code for the above logic
//-----
let transformedIngrident = Object.keys(props.ingredient) //["salad", "bacon", "cheese", "meat"]
transformedIngrident = transformedIngrident.map(igKey => { //igKey will pass string which will be mapped like salad then bacon then cheese and then meat

//This will tell the value corresponding to the give string of object for example in case of Salad it will show 1

//[undefined] -> This is because we have  one salad in Ingridents
//[undefined] -> This is because we have  one bacon
//[undefined, undefined, undefined] This is because we have  3 bacon
//[undefined, undefined] This is because we have two meat
  return [...Array(props.ingredient[igKey])].map((_, i) => {
    console.log(transformedIngrident)
      return <BurgerIngredients type={igKey} key={i} />
  //This will first create an empty array and the map used second time will map each ingrident into it with type and key
  })
})

////My Logic
//------
let transformedIngrident = Object.keys(props.ingredient)
var DisplayIngre = [] //this should be an array
var i;
var j;

for (i=0; i<transformedIngrident.length; i++){
  let keyValue = props.ingredient[transformedIngrident[i]]
  let igKey = transformedIngrident[i]
    for ( j=0; j<keyValue; j++) {
DisplayIngre.push(<BurgerIngredients type={igKey} key={i+j} />);
  }
}
//-------------------
//-------------------
//-------------------





Lecture 12
//Calculating the ingredient sum dynamically
//--------
//Max code
//If you console.log with max code, after setting everything in state to zero, We get 4 empty array
//Something like this -> (4) [Array(0), Array(0), Array(0), Array(0)], if we change salad to 2 then we would have something like this [Array(2), Array(0), Array(0), Array(0)] and so on
//Array contains 4 objects in case state of salad is 4 [Array(4) -> This will contain object
//The inner array are empty hence checking the length won't do the trick
//Hence we use reduce, In reduce what we did was, we created a function like this

transformedIngrident = transformedIngrident.reduce((curr, next) => {
  console.log("current")
  console.log(curr)
  console.log("next")
  console.log(next)
  console.log("tii")
  console.log(transformedIngrident)
    return [...curr, ...next]
}, []);

  console.log(transformedIngrident)

//Here current would be [Array 4 and everything inside it and next would be Array[0]]
so as it increments, it returns [...curr, ...next] this means everything of Array 4 and everything of next
So whenever it sees an empty array, it won't add and hence we will get length


//My code
//We do check over here only ->   for ( j=0; j<keyValue; j++) {, Hence we don't need to use reduce i.e if there is a keyValue then only it will push in
var DisplayIngre = [] which is an array

Hence we can simply do this (we don't need to use reduce method)

if (DisplayIngre.length === 0) {
DisplayIngre = <p> Kuch Nhi </p>
console.log(DisplayIngre)
}
//-------------------
//-------------------
//-------------------





//Lecture 13
//Adding Building control Component
//-----------
//Here we created a folder from user can add or remove components
//It consist of reusable buttons for which we created another folder named build-control-r -> build-control-r have buildcontrol.js and buildControl.css
//We added build-controls.js/css in Build-Control folder
//Note Build-Control-r is children of Build-Control
//We applied styling/css in build-control.js -> build.controls.css (and added div inside them)
//-------------------
//-------------------
//-------------------




//Lecture 14
//Outputting multiple Build Controls
//---------
//In this lecture we created an array of object where we added the label and and type.
//Inside parent Build-control, we import child build-controls
//We pass this array to child build-controls using map method
//This looks something like this
//{ controls.map(el =>(<BuildControl key={el.label} label={el.label} />))}
//We use key since it is an array at it would be unique here and label is passed to the child component
//-------------------
//-------------------
//-------------------




//Lecture 15
//Connecting states to the build-controls
//-------
addIngredientHandler = (type) => {
const oldCount = this.state.ingredient[type] //this shold log the value or the property next to it. for example 1 or 2
const updatedCount = oldCount + 1; //this should add one to whatever the count is
let updatedIngridents = {
  ...this.state.ingredient
};
updatedIngridents[type] = updatedCount;
const ingredientPrice = INGREDIENT_PRICE[type]
const  totalPrice = this.state[totalPrice]
const newPrice = totalPrice + ingredientPrice
this.setState({totalPrice: newPrice, ingredient: updatedIngridents});

//Here we get type when we call it from burger-controls
//const oldCount = this.state.ingredient[type] //this should log the value or the property next to it. for example 1 or 2
//const updatedCount = oldCount + 1; //this should add one to whatever the count is
//We make a copy of updatedIngridents in the next line
//updatedIngridents[type] = updatedCount; //This will update the key value of the object
const ingredientPrice = INGREDIENT_PRICE[type] //
//INGRIDENT PRICE is a global object which contains price of everything
//const  totalPrice = this.state.totalPrice -> will set the total price in our states
//const newPrice = totalPrice + ingredientPrice -> adds the cost of component to the total value
//this.setState({totalPrice: newPrice, ingredient: updatedIngridents}); -> Updates the state

//Then inside burgerBuilder
//we do something like this
<BuildControls
ingridentAdded={this.addIngredientHandler}/>
//to pass our addIngredientHandler

//Inside build-controls.js
//We pass the types which our app needs like this
ingridentAdded={() => props.ingridentAdded(el.type)}
//We get el.type from the const controls we created
//We send this to build-control and pass it as an onClick event
//-------------------
//-------------------
//-------------------


[Add a note about what happens inside burger ingredients -> https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/questions/4401532]

MLR — Teaching Assistant  · a day ago  Answer
Hi Rohit,  The general logic is:
#1)  Click the More (button) inside the BuildControl component > onClick={props.added}
#2)  BuildControls component > added={()=>props.ingredientAdded(ctrl.type)}
#3)  BurgerBuilder component > ingredientAdded={this.addIngredientHandler}
#4)  addIngredientHandler (method) > this.setState({totalPrice: newPrice, ingredients: updatedIngredients});
#5)  The state has been altered.
#6)  <Burger ingredients={this.state.ingredients} />
#7)  Burger component > Object.keys( ... ... The burger ingredients are processed.
//-------------------
//-------------------
//-------------------



//Lecture 16
//Removing and disabling button
//-------
//We did copied most of our code which we used above and changed const updatedCount = oldCount + 1; to const updatedCount = oldCount - 1; and const newPrice = totalPrice - ingredientPrice
//Now we want to disable the button if we have less than zero or zero keyValue pair
//For that we create a copy of our state.ingredients and call it disabledInfo inside our render method
//Then we use from in loop (for (key in disableinfo)) and then disableInfo[key] = disableInfo[key] <= 0
//Here it the latter disableInfor[key] if is greater than or equal to zero, it will set the value to true else fall
//we pass it like this  disabled={disabledInfo}/>
//In our   build-controls, we add  disabled={props.disabled[el.type]} -> here the key value pair would be either true or false now -> Since we copied this.state.ingrident to disableInfo and then changed the keyValue pair to true or false and then pass this to buildcontrols (this won't change our state)
//We pass it build-control and hence if the key value pair will be true, the button will be disabled
//-------------------
//-------------------
//-------------------


//Lecture 17
//Adding price
//-------
//We added price in this lecture
//Passed it to the burger-controls like form burgerBuilder.js like -> price={this.state.totalPrice.toFixed(2)} (to fix it to decimal places)
//ABove map, we did something like this <p> Your current price is {props.price}</p>
//-------------------
//-------------------
//-------------------


//Lecture 18
//Adding the order button
//-------
//Custom
//We created the order button using the button tag, we added its css
//then we put up if condition where if the price is 4 then it will change disability of button to true and the moment it changes to something other than 4 (since 4 is the base Price)
//it will change the disabled to true or false
//-------------------
//-------------------
//-------------------
