Note: In Index.css we setup global body style since rendor starts from Index.js and we import it in Index.js
//To change font-family from imported fonts from google -> Public -> Index.html
//We will use component to manage state and container for everything else
//<main> Tag is used to showcase main content
//IF we have two adjacent jsx element (we can't have), We have to use array and give each item a key
//Another alternate is create HOC -> It will server purpose of wrapping something and passing function
//Question to ask, Why didn't we used div?
https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/t/commit/8109010?start=0
//if we import react, can we use jsx anywhere?
//we can also add state using constructor(Props), super(props); this.state (this because we are inside a method)
//Burger project commit 11 to know how to pass states to functional component

//Burger Ingrident safe guarding.
https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/questions/3956582

More on CSS Modules
https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/t/commit/8111608

//Question.
//When we console.log(typeof array) -> Does it always logs it as an object

//To do
//Read flex properties (flex-flow, flex wrapper), display flex
..Read when do we use <Something> </something> and when do we use <something... />
.TO understand why do we make array of an object





//commit 5
//Css -> Npm run eject -> webpack -> Options
//Removed logo
//Removed most of the content from App.js
//Index.css change font
//removed App.css
//-------------------
//-------------------
//-------------------





//commit 6
//We can seperate our project into two parts
//Toolbar to navigate and the main burger builder
//We create a sub folder for layout
//We created Component and container -> we will create container in components because we don't need to manage any state
//In components -> Sub folder -> Layout -> in layout , layout.js file
//We create assests folder
//In layout.js, we use *main and there we will put component we will wrap with this content -> hence we will use props.children
//*We use this component as a wrapper around the core content component we want to render to the screen
//Now in main.js,we want have two adjacent element but since we cannot have two adjacet JSX element together, we create HOC named Aux
//Aux is simple -> Takes props and return props
//We import Aux to our Layout and layout to app
//Run the app afterwards
//-------------------
//-------------------
//-------------------





//commit 7
//Starting the implementation of the burger builder
//---x-x----x--x---
//This should actually be a container because here we need to manage the state of burger
//We created a new folder in container known as burger Builder
//Burger Builder contains Burger and Burger Controls
//We wrap it with Aux like we wrapped layout
//We imported it to App.js
//We wrapped it inside layout.js, Since we wrapped it inside Layout.js, We could add styling in Layout.css which will effect it since we are passing props.children
//We created layout.csss and added maegin of 16px
//Overflow: Scroll -> We can scroll it
//-------------------
//-------------------
//-------------------





//commit 8
//Adding DYnamic ingredient components
//---x----x-----x---
//We would add burger needed component and ingredients
//We added the CSS provided to us by Max
//We created Burger-ingredient cascade Style sheet and Burger-ingrident.js
//Now there would be different ingridents which we tend to send from Burger.js from props
//In burger-Ingrident.js file, we create a functional component and import react since we are going to use jsx
//We created a ingrident variable and set it as value to null because we don't want any invalid Value to be passed (more like let ingrident;) -> We won't render anything
//In Switch statement we do props.type -> type is the property we expect to receive -> based on the type we receive will use the case
//-------------------
//-------------------
//-------------------





//commit 9
//Props Valiadtion
//--x--x----x--
//Added Props Validation
//-------------------
//-------------------
//-------------------





//commit 10
//Starting the burger Component
//---x----x---
//In burger.js, we created a functional component which receives some props
//we imported react and BurgerIngredients.js
//We added types under <BurgerIngredients which will passed as props.type to our BurgerIngredients.js
//we created burger.css and added some css and media query
//All the props are static and added manually they look like this   <BurgerIngredients type="bread-top"/> <BurgerIngredients type="meat"/> and wrapped everything with div and added our own styling
//Since we are using switch statement > as we pass props.type > it will forward this to switch and hence display it
//We imported this to container > burger Builder > burger Builder.js
//-------------------
//-------------------
//-------------------





commit 11
//Outputting burger ingredient Dynamically
//----x-----x----
//We will add state, state is an object (in max tutorial) -> max
//We pass this array to burger Ingredients through  <Burger ingredient={this.state.ingrident}/> and convert this object to array using Object.keys
//Then we will use 1st map to find the property of the associated objected for example salad:1 -> we will find the property, which is one here -> this is done through
return [...Array(props.ingredient[igKey])] -> This will return a single empty array in case of 1, two empty array in case of 2 and so on..
will map this return and pass in the value of the string which will get as loop progress, this value is pushed in as form of JSX to form an Array
//SInce we are using one variable here, transformedIngrident, we use JSx to insert our value by doing something like this in return {transformedIngrident}

-----Max code alternate classical simplified version----

////Max code for the above logic
//-----
let transformedIngrident = Object.keys(props.ingredient) //["salad", "bacon", "cheese", "meat"]
transformedIngrident = transformedIngrident.map(igKey => { //igKey will pass string which will be mapped like salad then bacon then cheese and then meat

//This will tell the value corresponding to the give string of object for example in case of Salad it will show 1

//[undefined] -> This is because we have  one salad in Ingridents
//[undefined] -> This is because we have  one bacon
//[undefined, undefined, undefined] This is because we have  3 bacon
//[undefined, undefined] This is because we have two meat
  return [...Array(props.ingredient[igKey])].map((_, i) => {
    console.log(transformedIngrident)
      return <BurgerIngredients type={igKey} key={i} />
  //This will first create an empty array and the map used second time will map each ingrident into it with type and key
  })
})

////My Logic
//------
let transformedIngrident = Object.keys(props.ingredient)
var DisplayIngre = [] //this should be an array
var i;
var j;

for (i=0; i<transformedIngrident.length; i++){
  let keyValue = props.ingredient[transformedIngrident[i]]
  let igKey = transformedIngrident[i]
    for ( j=0; j<keyValue; j++) {
DisplayIngre.push(<BurgerIngredients type={igKey} key={i+j} />);
  }
}
//-------------------
//-------------------
//-------------------





commit 12
//Calculating the ingredient sum dynamically
//--------
//Max code
//If you console.log with max code, after setting everything in state to zero, We get 4 empty array
//Something like this -> (4) [Array(0), Array(0), Array(0), Array(0)], if we change salad to 2 then we would have something like this [Array(2), Array(0), Array(0), Array(0)] and so on
//Array contains 4 objects in case state of salad is 4 [Array(4) -> This will contain object
//The inner array are empty hence checking the length won't do the trick
//Hence we use reduce, In reduce what we did was, we created a function like this

transformedIngrident = transformedIngrident.reduce((curr, next) => {
  console.log("current")
  console.log(curr)
  console.log("next")
  console.log(next)
  console.log("tii")
  console.log(transformedIngrident)
    return [...curr, ...next]
}, []);

  console.log(transformedIngrident)

//Here current would be [Array 4 and everything inside it and next would be Array[0]]
so as it increments, it returns [...curr, ...next] this means everything of Array 4 and everything of next
So whenever it sees an empty array, it won't add and hence we will get length


//My code
//We do check over here only ->   for ( j=0; j<keyValue; j++) {, Hence we don't need to use reduce i.e if there is a keyValue then only it will push in
var DisplayIngre = [] which is an array

Hence we can simply do this (we don't need to use reduce method)

if (DisplayIngre.length === 0) {
DisplayIngre = <p> Kuch Nhi </p>
console.log(DisplayIngre)
}
//-------------------
//-------------------
//-------------------





//commit 13
//Adding Building control Component
//-----------
//Here we created a folder from user can add or remove components
//It consist of reusable buttons for which we created another folder named build-control-r -> build-control-r have buildcontrol.js and buildControl.css
//We added build-controls.js/css in Build-Control folder
//Note Build-Control-r is children of Build-Control
//We applied styling/css in build-control.js -> build.controls.css (and added div inside them)
//-------------------
//-------------------
//-------------------




//commit 14
//Outputting multiple Build Controls
//---------
//In this commit we created an array of object where we added the label and and type.
//Inside parent Build-control, we import child build-controls
//We pass this array to child build-controls using map method
//This looks something like this
//{ controls.map(el =>(<BuildControl key={el.label} label={el.label} />))}
//We use key since it is an array at it would be unique here and label is passed to the child component
//-------------------
//-------------------
//-------------------




//commit 15
//Connecting states to the build-controls
//-------
addIngredientHandler = (type) => {
const oldCount = this.state.ingredient[type] //this shold log the value or the property next to it. for example 1 or 2
const updatedCount = oldCount + 1; //this should add one to whatever the count is
let updatedIngridents = {
  ...this.state.ingredient
};
updatedIngridents[type] = updatedCount;
const ingredientPrice = INGREDIENT_PRICE[type]
const  totalPrice = this.state[totalPrice]
const newPrice = totalPrice + ingredientPrice
this.setState({totalPrice: newPrice, ingredient: updatedIngridents});

//Here we get type when we call it from burger-controls
//const oldCount = this.state.ingredient[type] //this should log the value or the property next to it. for example 1 or 2
//const updatedCount = oldCount + 1; //this should add one to whatever the count is
//We make a copy of updatedIngridents in the next line
//updatedIngridents[type] = updatedCount; //This will update the key value of the object
const ingredientPrice = INGREDIENT_PRICE[type] //
//INGRIDENT PRICE is a global object which contains price of everything
//const  totalPrice = this.state.totalPrice -> will set the total price in our states
//const newPrice = totalPrice + ingredientPrice -> adds the cost of component to the total value
//this.setState({totalPrice: newPrice, ingredient: updatedIngridents}); -> Updates the state

//Then inside burgerBuilder
//we do something like this
<BuildControls
ingridentAdded={this.addIngredientHandler}/>
//to pass our addIngredientHandler

//Inside build-controls.js
//We pass the types which our app needs like this
ingridentAdded={() => props.ingridentAdded(el.type)}
//We get el.type from the const controls we created
//We send this to build-control and pass it as an onClick event
//-------------------
//-------------------
//-------------------


[Add a note about what happens inside burger ingredients -> https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/questions/4401532]

MLR — Teaching Assistant  · a day ago  Answer
Hi Rohit,  The general logic is:
#1)  Click the More (button) inside the BuildControl component > onClick={props.added}
#2)  BuildControls component > added={()=>props.ingredientAdded(ctrl.type)}
#3)  BurgerBuilder component > ingredientAdded={this.addIngredientHandler}
#4)  addIngredientHandler (method) > this.setState({totalPrice: newPrice, ingredients: updatedIngredients});
#5)  The state has been altered.
#6)  <Burger ingredients={this.state.ingredients} />
#7)  Burger component > Object.keys( ... ... The burger ingredients are processed.
//-------------------
//-------------------
//-------------------



//commit 16
//Removing and disabling button
//-------
//We did copied most of our code which we used above and changed const updatedCount = oldCount + 1; to const updatedCount = oldCount - 1; and const newPrice = totalPrice - ingredientPrice
//Now we want to disable the button if we have less than zero or zero keyValue pair
//For that we create a copy of our state.ingredients and call it disabledInfo inside our render method
//Then we use from in loop (for (key in disableinfo)) and then disableInfo[key] = disableInfo[key] <= 0
//Here it the latter disableInfor[key] if is greater than or equal to zero, it will set the value to true else fall
//we pass it like this  disabled={disabledInfo}/>
//In our   build-controls, we add  disabled={props.disabled[el.type]} -> here the key value pair would be either true or false now -> Since we copied this.state.ingrident to disableInfo and then changed the keyValue pair to true or false and then pass this to buildcontrols (this won't change our state)
//We pass it build-control and hence if the key value pair will be true, the button will be disabled
//-------------------
//-------------------
//-------------------


//commit 17
//Adding price
//-------
//We added price in this commit
//Passed it to the burger-controls like form burgerBuilder.js like -> price={this.state.totalPrice.toFixed(2)} (to fix it to decimal places)
//ABove map, we did something like this <p> Your current price is {props.price}</p>
//-------------------
//-------------------
//-------------------


//commit 18
//Adding the order button
//-------
//Custom Method
//We created the order button using the button tag, we added its css
//then we put up if condition where if the price is 4 then it will change disability of button to true and the moment it changes to something other than 4 (since 4 is the base Price)
//it will change the disabled to true or false

Max Method
//Rewatch
//we added new state "purchasable" which is intially false and created a new method purchasableHandle
//we create a constant ppurchasable and check if the keyValue is everywhere zero by doing object keys followed by object map and then reduce method
//Object keys create an array of salad and everything, map will display the keyValue -> reduce will add everything, then we check if the sum is greater than 0 or not -> if greater than zero condtion is false
//We want this method to be executed whenever we add ingredient or remove an ingredient so we call it from those method
//We also pass ingrident as a argument to this handler to make sure we always have latest state
//-------------------
//-------------------
//-------------------


//commit 19
//Creating the order summary
//-------
//We created  folders in component  1. UI, Order Summary. Inside UI we created two folders -> Backdrop and Modal
//Modal creates a simple box in between the orderSummary is shown, we also added Model.CSS
//We imported Modal in BurgerBuilder and since We want order summary to be inside modal, we wrappped it inside Modal tag
//We passed the ingrident prop to ordersummary, used object.keys and then used .map to get ingredient and its summary (orderSummary is wrapped with AUx)
//-------------------
//-------------------
//-------------------


//commit 20
//-------
//Showing  and Hiding Modal
//We added purchasing into state which is intially set to false
//Purchasing is set to true when we click on order button for this we created purchasingHandler()
// we pass this state to modal and whenever this state is true it will make the box true
//Inside Modal we use ternary expression to determine if true and false and change style accordingly
//For example -> <div className={Classes.Modal} style={{display: props.order ? 'block' : 'none'}}>
//If we use purchasableHandler like this purchasable() and then do something like this.setState, it won't be pointing to the state because of the scope of this.. hence we need to use ES6 arrow function
//-------------------
//-------------------
//-------------------


//Commit 22 (21)
//------
//Implementing the Backdrop Component
//We created a backdrop folder having Backdrop.js and backdrop.css
//Backdrop is used to..
//We wrapped Model with Aux and then imported Backdrop.js file making modal as parent
//Order summary passes the prop through which backdrop adds its own styling when purchasable is true
//We also added purchasblecloseHandler which is bassed from BurgerBuilder to modal to Backdrop
//When purchasable state is true, meaning when we click on order now, an order popup summary opens
//The purchasableHandlerClose will close it whenever we click anywhere on the screen by setting it to false
//-------------------
//-------------------
//-------------------


//Commit 23
//-----
//Adding custom button component
//Since we are going to use button multiple times, we created a seperate component in UI (we created a button folder having its js file and CSS)
//We passed the purchasingHandlerClose from BurgerIngredient to ordersummary to Button.js file
//Button.js is child of ordersummary
//In button we want to add multiple styling so we create an array, join and then convert to string
//-------------------
//-------------------
//-------------------


//Commit 24
//-----
//Implementing the button Component
//We created a new handler the purchaseContinueHandler which just alerts something for the time being
//We passed this handler and purchasblecloseHandler the orderSummary which is passed to button.
//In button.js  we have.
//className={[Classes.Button, Classes[props.btnType]].join(' ')} and onClick={props.clicked}>
/Now there are many ways to get the props but one of the way is
   <Button btnType="Danger"  clicked={props.purchasingHandlerClose}>Cancel </Button>
   <Button btnType="Success"  clicked={props.purchaseContinueHandler}> Order</Button>
//In above example if cancel Button would be clicked then btnType Danger would be passed and similarly props associated with clicked
//-------------------
//-------------------
//-------------------


//Commit 25
//----
//Adding Price to order summary
//Passed the price from BurgerBuilder using this.state.total price to order Summary wrapper
//Outputted that price in Order Summary
//-------------------
//-------------------
//-------------------


//Commit 26
//-----
//We made toolbar folder, added toolbar.js and toolbar.css file
//Passed it to layout component (making layout the parent)
//Added css properties to toolbar
//-------------------
//-------------------
//-------------------
